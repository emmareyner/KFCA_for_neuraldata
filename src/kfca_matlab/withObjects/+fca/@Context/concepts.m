function [A,varargout]=concepts(K)
% Works out the set of formal concepts using Intersection of Intents (q.v.)
% - [B]=concepts(K), only returns intents (nice for counting concepts). Use
% extent.m to calculate the extents afterwards.
%
%  -  [A,B]=concepts(K) returns coindexed extents(A) and intents (B)
%
% - [A,B,la,lb] = concepts(K) returns coindexed extents (A) and intents (B)
% and columns la(K.g,1) and lb(K.m,1) where la(i) points at the extent
% generated by row i and lb(j) points at the intent generated by column j.
% THis is the basis for labelling A and B with the object and attribute
% reduced labellings.

%Check number of input args
%error(nargchk(1, 1, nargin))

%% Initialization
%Perhaps do a reduction before a clarification here!
I=full(K.I(K.iG,K.iM));%transform to full for obsolete operation

%% This carries out IntersectionIntents on I
switch nargout
    case 1
        A = concepts(I);
        varargout={};
    case 2
        [A, varargout{1}]=concepts(I);
        %varargout{1}=intent(I,A);
    case 4
%          [A,B,lobj,latt]=concepts(I);
%         varargout{1}=B;
%         varargout{2}=lobj;
%         varargout{3}=latt;
         [A varargout{1} varargout{2} varargout{3}]=...
            concepts(I);
%         [A varargout(1) varargout(2) varargout(3)]=...
%             IntersectionExtents(I);
%     if nargout == 2
%         for i=1:size(A,1)
%          A(i,:)=extent(B(i,:),K);%TODO: change extent to accept matrices.
%         end
%     end
    otherwise
        
end
% return
