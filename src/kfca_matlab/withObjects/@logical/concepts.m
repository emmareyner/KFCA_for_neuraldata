function [A,B,lobj,latt]=concepts(I)
% Works out the set of formal concepts using Intersection of Extents (q.v.)
% - [A]=concepts(I), only returns extents (nice for counting concepts). Use
% intent.m to calculate the intents afterwards.
%
%  -  [A,B]=concepts(I) returns coindexed extents(A) and intents (B)
%
% - [A,B,la,lb] = concepts(I) returns coindexed extents (A) and intents (B)
% and columns la(g,1) and lb(m,1) where la(i) points at the extent
% generated by row i and lb(j) points at the intent generated by column j.
%
% This is the basis for labelling A and B with the object and attribute
% reduced labellings.

%Check number of input args
%error(nargchk(1, 1, nargin))

%% Initialization

try
    c=es.uc3m.kfcatools.Concepts;
    At=c.getIntersectionExtents(I);
    A=At';
catch err
    disp('Please add es.uc3m.kfcatools.Concepts to your classpath: javaaddpath path');
    [A,latt] = IntersectionExtents(I);
end


%% Work out intents
if nargout > 1
    [B]= intent(I,A);
end

%% if needed calculate labels of extents
if nargout > 2
    %Go over matrix intents checking where they are
    %in the system of intents
    I = I';%cols are now object intents
    g=size(I,2);
    lobj=zeros(1,g);
    n=ones(1,size(B,2));
    for i = 1:g%permuted rows and cols
        match = ~any(double(xor(B,I(:,i)*n)));
        %at most one bit of match is true
        if any(match)
            lobj(i)=find(match);
        end
    end
end
return%[A,B,lobj,latt]
